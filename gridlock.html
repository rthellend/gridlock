<!DOCTYPE html>
<!--
 Copyright 2026 Robin Thellend <rthellend@gmail.com>

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="icon" href="gridlock.png" />
    <link rel="manifest" href="manifest.json" />
    <title>Gridlock</title>
    <style>
        :root {
            --cell-size: 50px;
            --gap-size: 2px;
            --bg-color: #f0f2f5;
            --board-bg: #2c3e50;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            touch-action: none;
        }

        /* --- HEADER --- */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 50;
            flex: 0 0 auto;
        }

        .header-title h1 { margin: 0; font-size: 1.2rem; color: #333; }
        .header-title p { margin: 2px 0 0; font-size: 0.8rem; color: #666; }

        .controls select {
            padding: 5px 10px;
            font-size: 1rem;
            border-radius: 4px;
            border: 1px solid #ccc;
            background: #f9f9f9;
        }

        /* --- LAYOUT --- */
        #game-layout {
            flex: 1;
            display: flex;
            /* CENTER THE BOARD */
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 1;
        }

        #board-zone {
            flex: 0 0 auto;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            z-index: 10; /* Keep board visible but conceptually 'below' flying pieces */
        }

        #board {
            display: grid;
            grid-template-columns: repeat(4, var(--cell-size));
            grid-template-rows: repeat(7, var(--cell-size));
            gap: var(--gap-size);
            background-color: var(--board-bg);
            border: 4px solid var(--board-bg);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }

        .board-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* TRAY REMOVED (Hidden) */
        #tray-zone {
            display: none;
        }

        #piece-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 100; pointer-events: none;
        }

        /* --- PIECE VISUALS --- */
        .piece {
            position: absolute;
            display: grid;
            gap: var(--gap-size);
            cursor: grab;
            pointer-events: none; /* Clicks pass through empty container space */
            touch-action: none;
            transition: transform 0.1s;
            filter:
                drop-shadow(1px 0 0 #444)
                drop-shadow(-1px 0 0 #444)
                drop-shadow(0 1px 0 #444)
                drop-shadow(0 -1px 0 #444)
                drop-shadow(3px 5px 8px rgba(0,0,0,0.5));
            transform-origin: center center;
            z-index: 20;
        }

        .piece:active {
            cursor: grabbing;
            transform: scale(1.05);
            z-index: 1000;
        }

        .piece.placed {
            z-index: 15;
        }

        .piece-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: #ffeeb0;
            pointer-events: auto; /* Restore events on tiles */
            box-shadow: inset 2px 2px 4px rgba(255,255,255,0.7),
                        inset -2px -2px 4px rgba(0,0,0,0.1);
            border: 1px solid #cbb26a;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- SYMBOLS --- */
        .board-cell .sym-0, .board-cell .sym-1, .board-cell .sym-2 {
            opacity: 0.15;
            filter: grayscale(30%);
        }

        .sym-0 { width: 50%; height: 50%; background: #2980b9; }
        .sym-1 { width: 60%; height: 60%; background: #c0392b; border-radius: 50%; }
        .sym-2 { position: relative; width: 60%; height: 60%; }
        .sym-2::before, .sym-2::after { content:''; position: absolute; background: #27ae60; }
        .sym-2::before { left: 40%; top: 0; width: 20%; height: 100%; }
        .sym-2::after { left: 0; top: 40%; width: 100%; height: 20%; }

        @media (max-width: 600px) {
            #game-layout { flex-direction: column; }
            #board-zone { padding: 10px; }
            #tray-zone { border-top: 2px solid #ccc; }
            header { flex-direction: column; gap: 10px; }
        }
    </style>
</head>
<body>

<header>
    <div class="header-title">
        <h1>Gridlock</h1>
        <p>Drag to move • Tap to rotate</p>
    </div>
    <div class="controls">
        <select id="level-select">
            </select>
    </div>
</header>

<div id="game-layout">
    <div id="board-zone">
        <div id="board"></div>
    </div>
    <div id="tray-zone"></div>
</div>

<div id="piece-layer"></div>

<script>
    // --- DATA ---
    const BOARD_LAYOUT = [
        [0, 2, 1, 1],
        [1, 0, 0, 2],
        [2, 2, 1, 2],
        [2, 0, 1, 0],
        [2, 0, 2, 2],
        [1, 0, 1, 1],
        [1, 1, 0, 0],
    ];

    const PIECES_DEFS = {
        A: [1, 2],
        B: [0, 2],
        C: [0, 1],
        D: [2, 2],
        E: [0, 0],
        F: [1, 1],
        G: [1, 0, 0],
        H: [1, 2, 0],
        I: [0, 1, 2],
        J: [2, 2, 0],
        K: [1, 1, 0],
        L: [0, 1, 1],
        M: [0, 2, 1],
        N: [2, 0, 1],
    };

    const LEVELS = [
        { id: 1, code: "AABCDDEFGIKN" },
        { id: 2, code: "ABCDDEFFGJKM" },
        { id: 3, code: "ABCCDEFFIJMN" },
        { id: 4, code: "ABDDEEFFIKMN" },
        { id: 5, code: "ABBCDEFFIJKM" },
        { id: 6, code: "ABBCCCDFIJKM" },
        { id: 7, code: "ABBCCCDDEFFKJ" },
        { id: 8, code: "ABBCCCDDHKLN" },
        { id: 9, code: "ABBBCCDDEFFHL" },
        { id: 10, code: "ABBBCCDDEFFLN" },
        { id: 11, code: "ABBBCCCDDFFGI" },
        { id: 12, code: "AABCDEFFGIJM" },
        { id: 13, code: "AABCDDEFGKNM" },
        { id: 14, code: "AABCDEFFGHIJ" },
        { id: 15, code: "AABCDEFFGJMN" },
        { id: 16, code: "AABCCDEFIJKM" },
        { id: 17, code: "AABCCDDEEFFHN" },
        { id: 18, code: "AABCCCDDGHIL" },
        { id: 19, code: "AABBCCDFGIJK" },
        { id: 20, code: "AABBCCDFGJLN" },
        { id: 21, code: "AABBCCCDEFFIJ" },
        { id: 22, code: "AABBCCCDEFFJN" },
        { id: 23, code: "AABBCCCDJKLM" },
        { id: 24, code: "AABBCCCDDEFHK" },
        { id: 25, code: "AABBCCCDEFFIJ" },
        { id: 26, code: "AABBFGIJKMN" },
        { id: 27, code: "AABBBCFFGJMN" },
        { id: 28, code: "AABBBCCCDDFGL" },
        { id: 29, code: "AAABCCDEEFFIJ" },
        { id: 30, code: "AAABCCDEEFFHJ" },
        { id: 31, code: "AAABCDDEEFFGN" },
        { id: 32, code: "AAABCCDDEEFKM" },
        { id: 33, code: "АААBBCEFJKMN" },
        { id: 34, code: "AAABBEFFGJMN" },
        { id: 35, code: "AAABBBCCCDFGH" },
        { id: 36, code: "AAABBBCCEFFIJ" },
        { id: 37, code: "AAABCDEFGIMN" },
        { id: 38, code: "AAABCCDDEEFHL" },
        { id: 39, code: "AAABCCCDGIJL" },
        { id: 40, code: "AAABBCEFIJKM" },
        { id: 41, code: "AAABBCCCDDEEFF" },
        { id: 42, code: "AAABBCCDGHKM" },
        { id: 43, code: "AAAABBCCDEFGI" },
        { id: 44, code: "AAACCCDEIJLN" },
        { id: 45, code: "AAABBBCCCIJLN" },
        { id: 46, code: "AAAABCCDEEFHM" },
        { id: 47, code: "AAAABCCDEEFIM" },
        { id: 48, code: "AAAABBBCCCFGJ" },
        { id: 49, code: "AAAABBBCCDEEFF" },
        { id: 50, code: "BBBDDEFFKLMN" },
    ];

    // --- CONFIG ---
    let cell_size = 50;
    const GAP = 2;
    const BORDER = 4;

    // Game State
    let piecesState = [];

    function init() {
        initControls();
        resize();
        renderBoard();
        loadLevel(0);

        window.addEventListener('resize', () => {
            resize();
            piecesState.forEach(p => {
                if (p.placed) snapToGrid(p);
                else placePieceRandomly(p);
                renderPiece(p);
            });
        });
    }

    function initControls() {
        const select = document.getElementById('level-select');
        LEVELS.forEach((lvl, index) => {
            const opt = document.createElement('option');
            opt.value = index;
            opt.innerText = `Puzzle ${lvl.id}`;
            select.appendChild(opt);
        });

        select.addEventListener('change', (e) => {
            loadLevel(parseInt(e.target.value));
        });
    }

    function loadLevel(index) {
        const layer = document.getElementById('piece-layer');
        layer.innerHTML = '';
        piecesState.length = 0;
        const levelCode = LEVELS[index].code;
        createPieces(levelCode);
    }

    function resize() {
        const h = window.innerHeight - 80;
        const w = window.innerWidth;

        // Calculate size allowing for margins (~2-3 cells on sides/top/bottom)
        const hSize = Math.floor(h / 12);
        const wSize = Math.floor(w / 8);

        cell_size = Math.min(60, Math.min(hSize, wSize));
        // Minimum size cap
        if (cell_size < 25) cell_size = 25;

        document.documentElement.style.setProperty('--cell-size', cell_size + 'px');
    }

    function renderBoard() {
        const board = document.getElementById('board');
        board.innerHTML = '';
        BOARD_LAYOUT.forEach((row, r) => {
            row.forEach((sym, c) => {
                const cell = document.createElement('div');
                cell.className = 'board-cell';
                cell.innerHTML = `<div class="sym-${sym}"></div>`;
                board.appendChild(cell);
            });
        });
    }

    function createPieces(codeStr) {
        const layer = document.getElementById('piece-layer');
        const list = codeStr.split('');

        list.forEach((char, i) => {
            const def = PIECES_DEFS[char];
            const p = {
                id: i,
                def: def,
                rot: Math.floor(Math.random() * 4),
                x: 0, y: 0,
                placed: false,
                gridPos: null,
                el: document.createElement('div'),
                isAnimating: false
            };

            p.el.className = 'piece';
            addInteraction(p);
            piecesState.push(p);
            layer.appendChild(p.el);

            // Initial Random Placement
            placePieceRandomly(p);
            renderPiece(p);
        });
    }

    // --- SMART SCATTER LOGIC ---
    function placePieceRandomly(p) {
        const boardEl = document.getElementById('board');
        const bRect = boardEl.getBoundingClientRect();

        const winW = window.innerWidth;
        const winH = window.innerHeight;

        const dims = getPieceDimensions(p.def.length, p.rot);
        const pW = dims.w;
        const pH = dims.h;

        let bestX = 0, bestY = 0;
        let foundSpot = false;

        // Try 50 times to find a non-overlapping spot
        for(let i=0; i<50; i++) {
            // Random position in safe area (avoiding extreme edges)
            const rx = 10 + Math.random() * (winW - pW - 20);
            const ry = 80 + Math.random() * (winH - pH - 90);

            // Proposed Rect
            const pRect = { left: rx, top: ry, right: rx+pW, bottom: ry+pH };

            // 1. Check Intersection with Board (Forbidden Zone)
            if (rectIntersect(pRect, bRect)) continue;

            // 2. Check Intersection with other PIECES
            let overlap = false;
            for(const other of piecesState) {
                if(other === p) continue;
                // Ignore uninitialized pieces
                if(other.x === 0 && other.y === 0) continue;

                const oDims = getPieceDimensions(other.def.length, other.rot);
                const oRect = { left: other.x, top: other.y, right: other.x+oDims.w, bottom: other.y+oDims.h };

                if (rectIntersect(pRect, oRect)) {
                    overlap = true;
                    break;
                }
            }

            if (!overlap) {
                bestX = rx;
                bestY = ry;
                foundSpot = true;
                break;
            }
            // Keep last attempt as fallback
            bestX = rx;
            bestY = ry;
        }

        p.x = bestX;
        p.y = bestY;
    }

    function rectIntersect(r1, r2) {
        return !(r2.left > r1.right ||
                 r2.right < r1.left ||
                 r2.top > r1.bottom ||
                 r2.bottom < r1.top);
    }

    function getPieceDimensions(size, rot) {
        const coords = getCoords(size, rot);
        const maxR = Math.max(...coords.map(c => c.r));
        const maxC = Math.max(...coords.map(c => c.c));
        const cols = maxC + 1;
        const rows = maxR + 1;
        return {
            w: (cols * cell_size) + ((cols - 1) * GAP),
            h: (rows * cell_size) + ((rows - 1) * GAP)
        };
    }

    function renderPiece(p) {
        const coords = getCoords(p.def.length, p.rot);
        const maxR = Math.max(...coords.map(c => c.r));
        const maxC = Math.max(...coords.map(c => c.c));
        const cols = maxC + 1;
        const rows = maxR + 1;

        p.el.style.gridTemplateRows = `repeat(${rows}, var(--cell-size))`;
        p.el.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
        p.el.classList.toggle('placed', p.placed);

        const width = (cols * cell_size) + ((cols - 1) * GAP);
        const height = (rows * cell_size) + ((rows - 1) * GAP);

        p.el.style.width = width + 'px';
        p.el.style.height = height + 'px';

        p.el.innerHTML = '';
        coords.forEach((pt, idx) => {
            const div = document.createElement('div');
            div.className = 'piece-cell';
            div.style.gridRow = pt.r + 1;
            div.style.gridColumn = pt.c + 1;
            const sym = p.def[idx];
            div.innerHTML = `<div class="sym-${sym}"></div>`;
            p.el.appendChild(div);
        });

        p.el.style.left = p.x + 'px';
        p.el.style.top = p.y + 'px';
    }

    function getCoords(size, rot) {
        let pts = (size === 2)
            ? [{r:0,c:0}, {r:1,c:0}]
            : [{r:0,c:0}, {r:1,c:0}, {r:1,c:1}];

        for(let i=0; i<rot; i++) {
            pts = pts.map(p => ({r: p.c, c: -p.r}));
        }

        const minR = Math.min(...pts.map(p => p.r));
        const minC = Math.min(...pts.map(p => p.c));
        return pts.map(p => ({r: p.r - minR, c: p.c - minC}));
    }

    function addInteraction(p) {
        let startX, startY, startLeft, startTop;
        let dragging = false;
        let startTime;

        const onDown = (e) => {
            e.preventDefault();
            if(p.isAnimating) return;

            dragging = false;
            startTime = Date.now();

            const touch = e.touches ? e.touches[0] : e;
            startX = touch.clientX;
            startY = touch.clientY;
            startLeft = p.x;
            startTop = p.y;

            p.el.classList.add('dragging');

            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
            document.addEventListener('touchmove', onMove, {passive: false});
            document.addEventListener('touchend', onUp);
        };

        const onMove = (e) => {
            const touch = e.touches ? e.touches[0] : e;
            const dx = touch.clientX - startX;
            const dy = touch.clientY - startY;

            if (!dragging && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
                dragging = true;
                if(p.placed) {
                    p.placed = false;
                    p.gridPos = null;
                }
            }

            if (dragging) {
                p.x = startLeft + dx;
                p.y = startTop + dy;
                p.el.style.left = p.x + 'px';
                p.el.style.top = p.y + 'px';
            }
        };

        const onUp = (e) => {
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
            document.removeEventListener('touchmove', onMove);
            document.removeEventListener('touchend', onUp);

            p.el.classList.remove('dragging');

            if (!dragging && (Date.now() - startTime < 300)) {
                handleTap(p);
            } else {
                handleDrop(p);
            }
        };

        p.el.addEventListener('mousedown', onDown);
        p.el.addEventListener('touchstart', onDown, {passive: false});
    }

    function handleTap(p) {
        if(!p.placed) {
            rotatePieceAnimate(p);
        }
    }

    function rotatePieceAnimate(p) {
        if (p.isAnimating) return;
        p.isAnimating = true;

        const w = parseFloat(p.el.style.width);
        const h = parseFloat(p.el.style.height);
        const cx = p.x + w / 2;
        const cy = p.y + h / 2;

        p.el.style.transition = 'transform 0.2s ease-out';
        p.el.style.transform = 'rotate(90deg) scale(1.1)';

        setTimeout(() => {
            p.rot = (p.rot + 1) % 4;
            p.el.style.transition = 'none';
            p.el.style.transform = 'none';
            renderPiece(p);

            const newW = parseFloat(p.el.style.width);
            const newH = parseFloat(p.el.style.height);
            p.x = cx - newW / 2;
            p.y = cy - newH / 2;
            p.el.style.left = p.x + 'px';
            p.el.style.top = p.y + 'px';

            void p.el.offsetWidth;
            p.el.style.transition = '';
            p.isAnimating = false;
        }, 200);
    }

    function handleDrop(p) {
        const board = document.getElementById('board');
        const bRect = board.getBoundingClientRect();
        const pRect = p.el.getBoundingClientRect();

        const pCenterX = pRect.left + pRect.width / 2;
        const pCenterY = pRect.top + pRect.height / 2;

        if (pCenterX > bRect.left && pCenterX < bRect.right &&
            pCenterY > bRect.top && pCenterY < bRect.bottom) {

            const relX = pRect.left - (bRect.left + BORDER);
            const relY = pRect.top - (bRect.top + BORDER);
            const step = cell_size + GAP;

            // 1. Primary Snap
            const centerC = Math.round(relX / step);
            const centerR = Math.round(relY / step);

            if (isValid(p, centerR, centerC)) {
                snapTo(p, centerR, centerC);
                return;
            }

            // 2. Tolerance Snap
            const candidates = [
                {r: centerR+1, c: centerC},
                {r: centerR-1, c: centerC},
                {r: centerR, c: centerC+1},
                {r: centerR, c: centerC-1}
            ];

            let bestMatch = null;
            let minDistance = Infinity;

            for (let cand of candidates) {
                if (isValid(p, cand.r, cand.c)) {
                    const candX = cand.c * step;
                    const candY = cand.r * step;
                    const dist = Math.hypot(relX - candX, relY - candY);

                    if (dist < cell_size * 0.6) {
                        if (dist < minDistance) {
                            minDistance = dist;
                            bestMatch = cand;
                        }
                    }
                }
            }

            if (bestMatch) {
                snapTo(p, bestMatch.r, bestMatch.c);
                return;
            }
        }
    }

    function snapTo(p, r, c) {
        p.placed = true;
        p.gridPos = {r: r, c: c};
        snapToGrid(p);
        renderPiece(p);
        checkWin();
    }

    function snapToGrid(p) {
        if (!p.placed) return;
        const board = document.getElementById('board');
        const bRect = board.getBoundingClientRect();
        const step = cell_size + GAP;
        p.x = bRect.left + BORDER + (p.gridPos.c * step);
        p.y = bRect.top + BORDER + (p.gridPos.r * step);
    }

    function ensureInBounds(p) {
        // Fallback constraint logic
        const winW = window.innerWidth;
        const winH = window.innerHeight;
        if (p.x < 0) p.x = 10;
        if (p.y < 0) p.y = 10;
        if (p.x > winW - 50) p.x = winW - 60;
        if (p.y > winH - 50) p.y = winH - 60;
    }

    function isValid(p, r, c) {
        const coords = getCoords(p.def.length, p.rot);
        for (let i=0; i<coords.length; i++) {
            const pt = coords[i];
            const tr = r + pt.r;
            const tc = c + pt.c;

            if (tr < 0 || tr >= 7 || tc < 0 || tc >= 4) return false;
            if (piecesState.some(o => o !== p && o.placed && checkOverlap(o, tr, tc))) return false;
            if (BOARD_LAYOUT[tr][tc] !== p.def[i]) return false;
        }
        return true;
    }

    function checkOverlap(other, tr, tc) {
        const coords = getCoords(other.def.length, other.rot);
        return coords.some(pt => (other.gridPos.r + pt.r) === tr && (other.gridPos.c + pt.c) === tc);
    }

    function checkWin() {
        if (piecesState.every(p => p.placed)) {
            setTimeout(() => alert("Puzzle Solved!"), 100);
        }
    }

    init();

</script>
</body>
</html>
